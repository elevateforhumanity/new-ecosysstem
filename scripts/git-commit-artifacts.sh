#!/usr/bin/env bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
COMMIT_MESSAGE_PREFIX="${COMMIT_MESSAGE_PREFIX:-chore(autopilot): build}"
BRANCH="${AUTOPILOT_BRANCH:-main}"
AUTHOR_NAME="${GIT_AUTHOR_NAME:-efh-autopilot}"
AUTHOR_EMAIL="${GIT_AUTHOR_EMAIL:-autopilot@elevateforhumanity.org}"

# Logging function
log() {
  echo -e "${1}"
}

# Check if we're in a git repository
check_git_repo() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log "${RED}‚ùå Not in a git repository${NC}"
    exit 1
  fi
}

# Configure git if needed
configure_git() {
  log "${BLUE}üîß Configuring git...${NC}"
  
  # Set user name and email if not already set
  if [ -z "$(git config user.name 2>/dev/null)" ]; then
    git config user.name "$AUTHOR_NAME"
    log "‚úÖ Set git user.name to: $AUTHOR_NAME"
  fi
  
  if [ -z "$(git config user.email 2>/dev/null)" ]; then
    git config user.email "$AUTHOR_EMAIL"
    log "‚úÖ Set git user.email to: $AUTHOR_EMAIL"
  fi
  
  # Configure git to handle large files and long paths
  git config core.longpaths true 2>/dev/null || true
  git config http.postBuffer 524288000 2>/dev/null || true
}

# Check for changes
check_changes() {
  log "${BLUE}üîç Checking for changes...${NC}"
  
  # Check if there are any changes to commit
  if git diff --quiet && git diff --cached --quiet; then
    log "${YELLOW}‚ÑπÔ∏è No changes to commit${NC}"
    return 1
  fi
  
  return 0
}

# Create commit message
create_commit_message() {
  local timestamp=$(date -u +%FT%TZ)
  local short_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "initial")
  
  # Count files changed
  local files_changed=$(git diff --name-only | wc -l)
  local files_staged=$(git diff --cached --name-only | wc -l)
  
  # Create detailed commit message
  local message="${COMMIT_MESSAGE_PREFIX} ${timestamp}

Autopilot build artifacts:
- Files modified: ${files_changed}
- Files staged: ${files_staged}
- Previous commit: ${short_hash}
- Build timestamp: ${timestamp}

Generated by: EFH Autopilot System
Co-authored-by: Ona <no-reply@ona.com>"

  echo "$message"
}

# Stage files intelligently
stage_files() {
  log "${BLUE}üì¶ Staging files...${NC}"
  
  # Stage all build artifacts and important files
  local patterns=(
    "dist/"
    "public/"
    "build/"
    "*.html"
    "*.xml"
    "*.txt"
    "*.json"
    "*.css"
    "*.js"
    "*.map"
    "sitemaps/"
    "robots.txt"
    "sitemap*.xml"
    ".autopilot-*"
  )
  
  # Add files that exist
  for pattern in "${patterns[@]}"; do
    if ls $pattern 1> /dev/null 2>&1; then
      git add "$pattern" 2>/dev/null || true
      log "‚úÖ Staged: $pattern"
    fi
  done
  
  # Remove deleted files
  git add -u 2>/dev/null || true
  
  # Show what's staged
  local staged_files=$(git diff --cached --name-only | wc -l)
  log "${GREEN}üìä Staged ${staged_files} files for commit${NC}"
  
  if [ "$staged_files" -eq 0 ]; then
    log "${YELLOW}‚ö†Ô∏è No files staged for commit${NC}"
    return 1
  fi
  
  return 0
}

# Commit changes
commit_changes() {
  log "${BLUE}üíæ Committing changes...${NC}"
  
  local commit_message=$(create_commit_message)
  
  # Create commit
  if git commit -m "$commit_message"; then
    local commit_hash=$(git rev-parse --short HEAD)
    log "${GREEN}‚úÖ Created commit: ${commit_hash}${NC}"
    
    # Save commit info for reference
    echo "{
  \"commit_hash\": \"$(git rev-parse HEAD)\",
  \"short_hash\": \"${commit_hash}\",
  \"timestamp\": \"$(date -u +%FT%TZ)\",
  \"message\": \"${COMMIT_MESSAGE_PREFIX}\",
  \"author\": \"${AUTHOR_NAME} <${AUTHOR_EMAIL}>\"
}" > dist/.last-commit.json
    
    return 0
  else
    log "${RED}‚ùå Failed to create commit${NC}"
    return 1
  fi
}

# Push changes
push_changes() {
  log "${BLUE}üöÄ Pushing to remote...${NC}"
  
  # Check if remote exists
  if ! git remote get-url origin > /dev/null 2>&1; then
    log "${YELLOW}‚ö†Ô∏è No remote 'origin' configured, skipping push${NC}"
    return 0
  fi
  
  # Check if branch exists on remote
  if ! git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
    log "${YELLOW}‚ö†Ô∏è Branch '$BRANCH' doesn't exist on remote, creating...${NC}"
    git push -u origin "$BRANCH" || {
      log "${RED}‚ùå Failed to push new branch${NC}"
      return 1
    }
  else
    # Push to existing branch
    if git push origin "$BRANCH"; then
      log "${GREEN}‚úÖ Successfully pushed to origin/$BRANCH${NC}"
    else
      log "${RED}‚ùå Failed to push to remote${NC}"
      return 1
    fi
  fi
  
  return 0
}

# Create git summary
create_summary() {
  log "${BLUE}üìä Creating git summary...${NC}"
  
  local summary="{
  \"timestamp\": \"$(date -u +%FT%TZ)\",
  \"branch\": \"$BRANCH\",
  \"commit_hash\": \"$(git rev-parse HEAD 2>/dev/null || echo 'none')\",
  \"short_hash\": \"$(git rev-parse --short HEAD 2>/dev/null || echo 'none')\",
  \"author\": \"${AUTHOR_NAME} <${AUTHOR_EMAIL}>\",
  \"files_committed\": $(git diff --name-only HEAD~1 2>/dev/null | wc -l || echo 0),
  \"repository_size\": \"$(du -sh .git 2>/dev/null | cut -f1 || echo 'unknown')\",
  \"total_commits\": $(git rev-list --count HEAD 2>/dev/null || echo 0)
}"
  
  echo "$summary" > dist/git-summary.json
  log "${GREEN}‚úÖ Git summary saved to dist/git-summary.json${NC}"
}

# Main function
main() {
  log "${BLUE}üöÄ Starting git commit process...${NC}"
  
  # Check prerequisites
  check_git_repo
  configure_git
  
  # Check for changes
  if ! check_changes; then
    log "${GREEN}‚úÖ No changes to commit, exiting${NC}"
    exit 0
  fi
  
  # Stage files
  if ! stage_files; then
    log "${YELLOW}‚ö†Ô∏è No files to stage, exiting${NC}"
    exit 0
  fi
  
  # Show diff summary
  log "${BLUE}üìã Changes summary:${NC}"
  git diff --cached --stat || true
  
  # Commit changes
  if ! commit_changes; then
    log "${RED}‚ùå Failed to commit changes${NC}"
    exit 1
  fi
  
  # Push changes (if configured)
  if [ "${AUTOPILOT_PUSH:-true}" = "true" ]; then
    if ! push_changes; then
      log "${YELLOW}‚ö†Ô∏è Push failed, but commit was successful${NC}"
      # Don't exit with error - commit succeeded
    fi
  else
    log "${YELLOW}‚ÑπÔ∏è Push disabled (AUTOPILOT_PUSH=false)${NC}"
  fi
  
  # Create summary
  create_summary
  
  log "${GREEN}üéâ Git commit process completed successfully${NC}"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --branch)
      BRANCH="$2"
      shift 2
      ;;
    --no-push)
      AUTOPILOT_PUSH=false
      shift
      ;;
    --message)
      COMMIT_MESSAGE_PREFIX="$2"
      shift 2
      ;;
    --author)
      AUTHOR_NAME="$2"
      shift 2
      ;;
    --email)
      AUTHOR_EMAIL="$2"
      shift 2
      ;;
    --help)
      echo "Usage: $0 [OPTIONS]"
      echo "Options:"
      echo "  --branch BRANCH     Target branch (default: main)"
      echo "  --no-push          Don't push to remote"
      echo "  --message MSG      Commit message prefix"
      echo "  --author NAME      Git author name"
      echo "  --email EMAIL      Git author email"
      echo "  --help             Show this help message"
      exit 0
      ;;
    *)
      log "${RED}‚ùå Unknown option: $1${NC}"
      exit 1
      ;;
  esac
done

# Run main function
main